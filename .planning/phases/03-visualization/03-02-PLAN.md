---
phase: 03-visualization
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - app/components/BubbleChart.tsx
  - app/components/Bubble.tsx
autonomous: true

must_haves:
  truths:
    - "SVG canvas renders bubbles with D3 force physics"
    - "Bubble size correlates with trend popularity score"
    - "Each bubble displays trend name, score, and change %"
    - "Bubbles animate smoothly as forces stabilize"
    - "Larger bubbles naturally gravitate toward center"
  artifacts:
    - path: "app/components/BubbleChart.tsx"
      provides: "Main bubble chart container with force simulation"
      min_lines: 80
      exports: ["BubbleChart"]
    - path: "app/components/Bubble.tsx"
      provides: "Individual bubble component with text wrapping"
      min_lines: 60
      exports: ["Bubble"]
  key_links:
    - from: "app/components/BubbleChart.tsx"
      to: "lib/hooks/useForceSimulation"
      via: "useForceSimulation hook call"
      pattern: "useForceSimulation\\("
    - from: "app/components/BubbleChart.tsx"
      to: "d3.scaleSqrt"
      via: "radius scaling"
      pattern: "d3\\.scaleSqrt"
    - from: "app/components/Bubble.tsx"
      to: "d3plus-text"
      via: "TextBox for label wrapping"
      pattern: "import.*TextBox.*from ['\"]d3plus-text['\"]"
---

<objective>
Build animated bubble visualization components with D3 force physics.

Purpose: Create the core visualization - an SVG canvas where trend bubbles animate via force simulation. Implements VIZ-01 through VIZ-06 (animated bubbles, size scaling, center gravity, labels).

Output: Working BubbleChart and Bubble components that render trends as animated, labeled circles.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/intel/summary.md
@.planning/phases/03-visualization/03-RESEARCH.md
@.planning/phases/03-visualization/03-01-SUMMARY.md

# Use these hooks created in 03-01
@lib/hooks/useForceSimulation.ts
@lib/hooks/useResizeObserver.ts
@lib/visualization/types.ts

# Trend data structure
@lib/fetchers/types.ts
</context>

<tasks>

<task type="auto">
  <name>Create BubbleChart container component</name>
  <files>app/components/BubbleChart.tsx</files>
  <action>
    Create BubbleChart component that:
    1. Accepts TrendWithHistory[] as props
    2. Converts trends to BubbleNodes with radius scaling
    3. Uses useForceSimulation for physics
    4. Renders SVG with Bubble components

    ```typescript
    'use client';

    import { useEffect, useState, useMemo } from 'react';
    import * as d3 from 'd3';
    import { useForceSimulation } from '@/lib/hooks/useForceSimulation';
    import type { TrendWithHistory } from '@/lib/fetchers/types';
    import type { BubbleNode } from '@/lib/visualization/types';
    import { Bubble } from './Bubble';

    interface BubbleChartProps {
      trends: TrendWithHistory[];
      width: number;
      height: number;
      onBubbleClick?: (trend: TrendWithHistory) => void;
    }

    export function BubbleChart({ trends, width, height, onBubbleClick }: BubbleChartProps) {
      // Convert trends to bubble nodes with radius scaling
      const nodes = useMemo(() => {
        const radiusScale = d3.scaleSqrt()
          .domain([0, 100])
          .range([20, 80]); // Min 20px, max 80px radius

        return trends.map(trend => ({
          id: trend.title,
          title: trend.title,
          score: trend.score,
          changePercent: trend.changePercent,
          radius: radiusScale(trend.score),
        }));
      }, [trends]);

      // Run force simulation
      const animatedNodes = useForceSimulation(nodes, width, height);

      // Map nodes back to trends for click handler
      const nodeToTrend = useMemo(() => {
        const map = new Map<string, TrendWithHistory>();
        trends.forEach(t => map.set(t.title, t));
        return map;
      }, [trends]);

      return (
        <svg width={width} height={height} className="bg-white">
          {animatedNodes.map(node => (
            <Bubble
              key={node.id}
              x={node.x ?? 0}
              y={node.y ?? 0}
              radius={node.radius}
              title={node.title}
              score={node.score}
              changePercent={node.changePercent}
              onClick={() => {
                const trend = nodeToTrend.get(node.id);
                if (trend && onBubbleClick) {
                  onBubbleClick(trend);
                }
              }}
            />
          ))}
        </svg>
      );
    }
    ```

    CRITICAL:
    - Use d3.scaleSqrt() not scaleLinear() (area should be proportional to score, not radius)
    - Mark 'use client' at top
    - useMemo for nodes to avoid recreation on every render
    - Pass onBubbleClick callback for modal trigger (wired in 03-04)
  </action>
  <verify>
    TypeScript compiles app/components/BubbleChart.tsx without errors.
    Component accepts trends, width, height props.
    Component uses useForceSimulation hook.
  </verify>
  <done>
    BubbleChart component renders SVG with animated bubbles.
    Radius scales with sqrt of score (area proportional).
    onBubbleClick prop enables click handling.
  </done>
</task>

<task type="auto">
  <name>Create Bubble component with text wrapping</name>
  <files>app/components/Bubble.tsx</files>
  <action>
    Create Bubble component with d3plus-text for label wrapping:

    ```typescript
    'use client';

    import { useEffect, useRef } from 'react';
    import { TextBox } from 'd3plus-text';

    interface BubbleProps {
      x: number;
      y: number;
      radius: number;
      title: string;
      score: number;
      changePercent: number;
      onClick?: () => void;
    }

    export function Bubble({ x, y, radius, title, score, changePercent, onClick }: BubbleProps) {
      const textRef = useRef<SVGGElement>(null);

      // Render wrapped text with d3plus-text
      useEffect(() => {
        if (!textRef.current) return;

        new TextBox()
          .select(textRef.current)
          .data([{
            text: title,
            x: x,
            y: y - radius * 0.3, // Position above score
          }])
          .fontSize(12)
          .fontMin(8)
          .fontMax(16)
          .width(radius * 1.6)
          .height(radius * 0.8) // Upper portion for title
          .textAnchor('middle')
          .verticalAlign('top')
          .fontColor('#ffffff')
          .fontWeight(600)
          .render();
      }, [x, y, radius, title]);

      // Color: green for positive change, red for negative
      const color = changePercent >= 0 ? '#22c55e' : '#ef4444';

      return (
        <g
          onClick={onClick}
          style={{ cursor: 'pointer' }}
          className="bubble"
        >
          {/* Bubble circle */}
          <circle
            cx={x}
            cy={y}
            r={radius}
            fill={color}
            fillOpacity={0.7}
            stroke="#ffffff"
            strokeWidth={2}
            className="transition-colors hover:opacity-90"
          />

          {/* Wrapped title text */}
          <g ref={textRef} />

          {/* Score (bold, center) */}
          <text
            x={x}
            y={y + radius * 0.2}
            textAnchor="middle"
            fontSize={14}
            fontWeight="bold"
            fill="#ffffff"
          >
            {score.toFixed(0)}
          </text>

          {/* Change percentage (below score) */}
          <text
            x={x}
            y={y + radius * 0.4}
            textAnchor="middle"
            fontSize={10}
            fill="#ffffff"
          >
            {changePercent > 0 ? '+' : ''}{changePercent.toFixed(1)}%
          </text>
        </g>
      );
    }
    ```

    CRITICAL:
    - Use d3plus-text for title wrapping (SVG lacks native wrapping)
    - Green (#22c55e) for positive change, red (#ef4444) for negative
    - White text for readability on colored bubbles
    - Min 40px diameter (20px radius) for mobile tap targets
    - Hover opacity change for interactivity feedback
  </action>
  <verify>
    TypeScript compiles app/components/Bubble.tsx without errors.
    Component renders circle, wrapped title, score, and change %.
    d3plus-text TextBox renders without errors.
  </verify>
  <done>
    Bubble component displays trend name (wrapped), score, change %.
    Colors indicate trend direction (green up, red down).
    Click handler prop enables modal triggering.
    Text wrapping works via d3plus-text.
  </done>
</task>

</tasks>

<verification>
Run all verification commands:
- npm run build (TypeScript compilation succeeds)
- Check both component files exist with 'use client' directive
- Verify BubbleChart imports useForceSimulation
- Verify Bubble imports TextBox from d3plus-text
</verification>

<success_criteria>
1. BubbleChart component renders SVG canvas
2. BubbleChart converts trends to BubbleNodes with sqrt radius scaling
3. BubbleChart uses useForceSimulation for physics
4. Bubble component renders circle with title, score, change %
5. Bubble uses d3plus-text for title wrapping
6. Bubble colors: green for positive change, red for negative
7. Both components marked 'use client'
8. Click handlers enable modal triggering (wired in 03-04)
</success_criteria>

<output>
After completion, create `.planning/phases/03-visualization/03-02-SUMMARY.md`
</output>
