---
phase: 03-visualization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - package-lock.json
  - lib/hooks/useForceSimulation.ts
  - lib/hooks/useResizeObserver.ts
  - lib/visualization/types.ts
  - lib/visualization/forces.ts
autonomous: true

must_haves:
  truths:
    - "D3 dependencies installed and importable"
    - "useForceSimulation hook calculates bubble positions via D3 physics"
    - "useResizeObserver hook detects container resize events"
  artifacts:
    - path: "package.json"
      provides: "d3 and d3plus-text dependencies"
      contains: "d3"
    - path: "lib/hooks/useForceSimulation.ts"
      provides: "D3 force simulation hook"
      min_lines: 50
      exports: ["useForceSimulation"]
    - path: "lib/hooks/useResizeObserver.ts"
      provides: "ResizeObserver hook"
      min_lines: 30
      exports: ["useResizeObserver"]
    - path: "lib/visualization/types.ts"
      provides: "BubbleNode type definition"
      exports: ["BubbleNode"]
    - path: "lib/visualization/forces.ts"
      provides: "Force configuration factory"
      exports: ["createBubbleSimulation"]
  key_links:
    - from: "lib/hooks/useForceSimulation.ts"
      to: "d3"
      via: "import * as d3"
      pattern: "import.*d3.*from ['\"]d3['\"]"
    - from: "lib/hooks/useForceSimulation.ts"
      to: "lib/visualization/types.ts"
      via: "BubbleNode type import"
      pattern: "import.*BubbleNode"
    - from: "lib/visualization/forces.ts"
      to: "d3.forceSimulation"
      via: "creates force simulation"
      pattern: "d3\\.forceSimulation"
---

<objective>
Set up D3 visualization infrastructure for animated bubble chart.

Purpose: Install D3 dependencies and create reusable hooks for force simulation physics and responsive sizing. This establishes the foundation for all visualization components.

Output: Working hooks and helper functions that later components will use to render animated bubbles.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/intel/summary.md
@.planning/phases/03-visualization/03-RESEARCH.md

# Existing types to extend
@lib/fetchers/types.ts
</context>

<tasks>

<task type="auto">
  <name>Install D3 dependencies</name>
  <files>package.json, package-lock.json</files>
  <action>
    Install D3 and d3plus-text:
    ```bash
    npm install d3 d3plus-text
    npm install --save-dev @types/d3
    ```

    D3 v7+ provides modular packages (d3-force, d3-scale) in single import.
    d3plus-text handles SVG text wrapping (SVG lacks native wrapping).
  </action>
  <verify>
    npm list d3 d3plus-text shows both installed.
    node -e "console.log(require('d3').version)" prints version number.
  </verify>
  <done>
    package.json contains d3 and d3plus-text dependencies.
    TypeScript types for D3 installed.
  </done>
</task>

<task type="auto">
  <name>Create visualization types</name>
  <files>lib/visualization/types.ts</files>
  <action>
    Create BubbleNode type extending D3's SimulationNodeDatum:

    ```typescript
    import type { SimulationNodeDatum } from 'd3';

    /**
     * Node data for bubble visualization
     * Extends D3's SimulationNodeDatum with fashion trend properties
     */
    export interface BubbleNode extends SimulationNodeDatum {
      /** Unique identifier (trend title) */
      id: string;
      /** Trend title to display */
      title: string;
      /** Normalized popularity score (0-100) */
      score: number;
      /** Daily change percentage */
      changePercent: number;
      /** Bubble radius (calculated from score) */
      radius: number;
    }
    ```

    D3's SimulationNodeDatum provides x, y, vx, vy properties automatically.
  </action>
  <verify>
    TypeScript compiles lib/visualization/types.ts without errors.
    BubbleNode type has all 5 custom properties plus inherited D3 properties.
  </verify>
  <done>
    lib/visualization/types.ts exports BubbleNode type.
    Type extends SimulationNodeDatum for D3 compatibility.
  </done>
</task>

<task type="auto">
  <name>Create force configuration helper</name>
  <files>lib/visualization/forces.ts</files>
  <action>
    Create createBubbleSimulation factory function following 03-RESEARCH.md patterns:

    ```typescript
    import * as d3 from 'd3';
    import type { BubbleNode } from './types';

    /**
     * Create D3 force simulation for bubble chart
     *
     * Configures collision, center, and charge forces for Crypto Bubbles-style layout.
     * Larger bubbles naturally drift to center due to collision dynamics.
     *
     * @param nodes - Array of bubble nodes
     * @param width - Container width
     * @param height - Container height
     * @returns Configured D3 force simulation
     */
    export function createBubbleSimulation(
      nodes: BubbleNode[],
      width: number,
      height: number
    ) {
      return d3.forceSimulation(nodes)
        // Many-body charge for repulsion (prevents overlap)
        .force('charge', d3.forceManyBody()
          .strength(d => -Math.pow(d.radius, 2) * 0.05)
        )
        // Center force pulls to middle (weak, let collisions dominate)
        .force('center', d3.forceCenter(width / 2, height / 2)
          .strength(0.05)
        )
        // Collision force prevents bubble overlap
        .force('collision', d3.forceCollide<BubbleNode>()
          .radius(d => d.radius + 5) // 5px padding
          .strength(0.8)
          .iterations(2)
        )
        // Slower cooling for smoother animation
        .alpha(1)
        .alphaDecay(0.02)
        .velocityDecay(0.4)
        .alphaMin(0.001);
    }
    ```

    Use config from 03-RESEARCH.md: charge proportional to bubble area, weak center force (0.05), collision with 5px padding.
  </action>
  <verify>
    TypeScript compiles lib/visualization/forces.ts without errors.
    Function signature matches: (nodes, width, height) => Simulation.
  </verify>
  <done>
    lib/visualization/forces.ts exports createBubbleSimulation.
    Force configuration matches research recommendations.
  </done>
</task>

<task type="auto">
  <name>Create useForceSimulation hook</name>
  <files>lib/hooks/useForceSimulation.ts</files>
  <action>
    Create custom hook managing D3 force simulation lifecycle:

    ```typescript
    'use client';

    import { useEffect, useState, useRef } from 'react';
    import type { Simulation } from 'd3';
    import { createBubbleSimulation } from '@/lib/visualization/forces';
    import type { BubbleNode } from '@/lib/visualization/types';

    export function useForceSimulation(
      nodes: BubbleNode[],
      width: number,
      height: number
    ) {
      const [animatedNodes, setAnimatedNodes] = useState<BubbleNode[]>(nodes);
      const simulationRef = useRef<Simulation<BubbleNode, undefined> | null>(null);

      useEffect(() => {
        if (nodes.length === 0 || width === 0 || height === 0) return;

        // Create simulation
        const simulation = createBubbleSimulation(nodes, width, height);
        simulationRef.current = simulation;

        // Update React state on each tick
        simulation.on('tick', () => {
          setAnimatedNodes([...simulation.nodes()]);
        });

        return () => {
          simulation.stop();
        };
      }, [nodes.length, width, height]);

      // Update node data when input changes
      useEffect(() => {
        if (simulationRef.current && nodes.length > 0) {
          simulationRef.current.nodes(nodes);
          simulationRef.current.alpha(0.3).restart();
        }
      }, [nodes]);

      return animatedNodes;
    }
    ```

    CRITICAL: Use 'use client' directive (D3 requires browser APIs).
    Store simulation in ref to avoid recreation on every render.
    Clone nodes array in tick handler to trigger React re-render.
  </action>
  <verify>
    TypeScript compiles lib/hooks/useForceSimulation.ts without errors.
    Hook returns BubbleNode[] with updated x/y coordinates.
  </verify>
  <done>
    useForceSimulation hook manages D3 lifecycle.
    Hook properly cleans up simulation on unmount.
    'use client' directive present at top of file.
  </done>
</task>

<task type="auto">
  <name>Create useResizeObserver hook</name>
  <files>lib/hooks/useResizeObserver.ts</files>
  <action>
    Create ResizeObserver hook for responsive SVG sizing:

    ```typescript
    'use client';

    import { useEffect, useRef, useState } from 'react';

    export function useResizeObserver<T extends HTMLElement>() {
      const ref = useRef<T>(null);
      const [dimensions, setDimensions] = useState({ width: 0, height: 0 });

      useEffect(() => {
        if (!ref.current) return;

        const observeTarget = ref.current;
        const resizeObserver = new ResizeObserver(entries => {
          entries.forEach(entry => {
            setDimensions({
              width: entry.contentRect.width,
              height: entry.contentRect.height,
            });
          });
        });

        resizeObserver.observe(observeTarget);

        return () => {
          resizeObserver.disconnect();
        };
      }, []);

      return { ref, dimensions };
    }
    ```

    Use native ResizeObserver API (supported in all modern browsers).
    Properly disconnect observer on cleanup.
  </action>
  <verify>
    TypeScript compiles lib/hooks/useResizeObserver.ts without errors.
    Hook returns { ref, dimensions: { width, height } }.
  </verify>
  <done>
    useResizeObserver hook detects container size changes.
    Hook properly cleans up observer on unmount.
    'use client' directive present.
  </done>
</task>

</tasks>

<verification>
Run all verification commands:
- npm list d3 d3plus-text (dependencies installed)
- npm run build (TypeScript compilation succeeds)
- Check all 5 files exist and export expected functions/types
</verification>

<success_criteria>
1. D3 and d3plus-text dependencies installed
2. BubbleNode type defined with id, title, score, changePercent, radius
3. createBubbleSimulation factory creates properly configured force simulation
4. useForceSimulation hook manages D3 lifecycle with React state updates
5. useResizeObserver hook detects container size changes
6. All TypeScript compilation passes
7. All hooks marked with 'use client' directive
</success_criteria>

<output>
After completion, create `.planning/phases/03-visualization/03-01-SUMMARY.md`
</output>
