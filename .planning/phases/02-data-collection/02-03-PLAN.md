---
phase: 02-data-collection
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - lib/normalizers/score-normalizer.ts
  - lib/database/trend-repository.ts
autonomous: true

must_haves:
  truths:
    - "Google Trends scores normalized to 0-100 scale"
    - "Trends saved to database with source tracking"
    - "Historical snapshots created for change tracking"
  artifacts:
    - path: "lib/normalizers/score-normalizer.ts"
      provides: "Score normalization"
      exports: ["normalizeScores"]
    - path: "lib/database/trend-repository.ts"
      provides: "Database operations for trends"
      exports: ["saveTrendsWithHistory", "getTrendsWithChange"]
  key_links:
    - from: "lib/normalizers/score-normalizer.ts"
      to: "lib/fetchers/types.ts"
      via: "RawTrend, NormalizedTrend types"
      pattern: "RawTrend|NormalizedTrend"
    - from: "lib/database/trend-repository.ts"
      to: "lib/supabase/server.ts"
      via: "createClient()"
      pattern: "createClient"
    - from: "lib/database/trend-repository.ts"
      to: "supabase.from('trends')"
      via: "upsert operations"
      pattern: "from\\('trends'\\)"
---

<objective>
Create score normalization and database persistence layer.

Purpose: Normalize Google Trends traffic strings (e.g., "50K+") to consistent 0-100 scale. Save trends to Supabase with history tracking for change calculations.
Output: Normalizer that produces consistent scores and repository that persists trends with history.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-collection/02-RESEARCH.md
@lib/fetchers/types.ts
@lib/supabase/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create score normalizer</name>
  <files>lib/normalizers/score-normalizer.ts</files>
  <action>
Create `lib/normalizers/score-normalizer.ts`:

Import types from `@/lib/fetchers/types`.

Create `normalizeScores(trends: RawTrend[]): NormalizedTrend[]`:

1. Google Trends returns traffic strings like "50K+", "1M+", "500+"
   - Parse these to numeric values first
   - Then apply min-max normalization to scale to 0-100

2. Helper function to parse traffic strings:
   ```typescript
   function parseTraffic(traffic: string | number): number {
     if (typeof traffic === 'number') return traffic;
     const str = traffic.replace('+', '').trim().toUpperCase();
     if (str.endsWith('M')) return parseFloat(str) * 1_000_000;
     if (str.endsWith('K')) return parseFloat(str) * 1_000;
     return parseFloat(str) || 0;
   }
   ```

3. Min-max normalization:
   ```typescript
   function minMaxNormalize(values: number[]): number[] {
     if (values.length === 0) return [];
     const min = Math.min(...values);
     const max = Math.max(...values);
     if (max === min) return values.map(() => 50); // All equal = 50
     return values.map(v => ((v - min) / (max - min)) * 100);
   }
   ```

4. Map each trend to NormalizedTrend:
   ```typescript
   {
     title: trend.title,
     score: normalizedScore, // 0-100
     sources: ['google'],
     sourceBreakdown: {
       google: normalizedScore
     },
     metadata: trend.metadata
   }
   ```

5. Return array of NormalizedTrend[]

Export the function.
  </action>
  <verify>
`npx tsc --noEmit` passes.
Manual test: parseTraffic("50K+") returns 50000, parseTraffic("1M+") returns 1000000.
  </verify>
  <done>
Score normalizer exports normalizeScores function.
Traffic strings parsed and scaled to 0-100 via min-max normalization.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create trend repository</name>
  <files>lib/database/trend-repository.ts</files>
  <action>
Create `lib/database/trend-repository.ts`:

Import createClient from `@/lib/supabase/server`.
Import types from `@/lib/fetchers/types`.

Create `saveTrendsWithHistory(trends: NormalizedTrend[]): Promise<void>`:

1. Get Supabase client
2. Get today's date string: `new Date().toISOString().split('T')[0]`
3. For each trend:
   a. Upsert to `trends` table:
      ```typescript
      const { data: trendData, error } = await supabase
        .from('trends')
        .upsert({
          title: trend.title,
          description: null, // Will be enriched later
          current_score: trend.score,
          updated_at: new Date().toISOString(),
        }, {
          onConflict: 'title',
        })
        .select('id')
        .single();
      ```
   b. If trend exists, update its score. If new, insert.

   c. Upsert to `trend_sources` for each source:
      ```typescript
      for (const source of trend.sources) {
        await supabase
          .from('trend_sources')
          .upsert({
            trend_id: trendData.id,
            source_name: source,
            source_score: trend.sourceBreakdown[source] || 0,
            fetched_at: new Date().toISOString(),
          }, {
            onConflict: 'trend_id,source_name',
          });
      }
      ```

   d. Upsert to `trend_history` for daily snapshot:
      ```typescript
      await supabase
        .from('trend_history')
        .upsert({
          trend_id: trendData.id,
          snapshot_date: today,
          data_snapshot: {
            score: trend.score,
            sources: trend.sources,
            sourceBreakdown: trend.sourceBreakdown,
          },
        }, {
          onConflict: 'trend_id,snapshot_date',
        });
      ```

4. Log success count or errors

Create `getTrendsWithChange(): Promise<TrendWithHistory[]>`:

1. Get today and yesterday date strings
2. Fetch all trends with their history:
   ```typescript
   const { data } = await supabase
     .from('trends')
     .select(`
       id,
       title,
       current_score,
       trend_history!inner (
         snapshot_date,
         data_snapshot
       )
     `)
     .order('current_score', { ascending: false });
   ```
3. For each trend, calculate change:
   - Find yesterday's snapshot
   - If exists: change = current_score - yesterday_score
   - If not exists: change = null (new trend)
4. Return TrendWithHistory[] sorted by score

Handle errors gracefully - log and throw descriptive errors.
  </action>
  <verify>
`npx tsc --noEmit` passes.
Functions match expected signatures in types.ts.
  </verify>
  <done>
Trend repository exports saveTrendsWithHistory and getTrendsWithChange.
Upserts trends, sources, and history to Supabase.
Calculates daily change percentage from history.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npm run build`
2. Normalizer handles edge cases (empty array, single item, all same score)
3. Repository functions have proper Supabase client usage
4. History tracking uses correct date format for snapshot_date
</verification>

<success_criteria>
- [ ] lib/normalizers/score-normalizer.ts exports normalizeScores
- [ ] Traffic strings parsed correctly ("50K+" -> 50000)
- [ ] Min-max normalization scales to 0-100
- [ ] lib/database/trend-repository.ts exports saveTrendsWithHistory, getTrendsWithChange
- [ ] Trends upserted by title (no duplicates)
- [ ] Source scores saved to trend_sources table
- [ ] Daily snapshots saved to trend_history table
- [ ] Change calculation compares today vs yesterday
- [ ] TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-collection/02-03-SUMMARY.md`
</output>
