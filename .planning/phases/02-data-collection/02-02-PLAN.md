---
phase: 02-data-collection
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/fetchers/google-trends.ts
  - app/api/test/google-trends/route.ts
autonomous: true

must_haves:
  truths:
    - "Google Trends fetcher retrieves daily trending searches"
    - "Fetcher filters results for fashion-related trends"
    - "Fetcher caches results to avoid hitting API repeatedly"
    - "Fetcher gracefully degrades when API fails"
  artifacts:
    - path: "lib/fetchers/google-trends.ts"
      provides: "Google Trends data fetching"
      exports: ["fetchGoogleTrends"]
    - path: "app/api/test/google-trends/route.ts"
      provides: "Manual test endpoint"
      exports: ["GET"]
  key_links:
    - from: "lib/fetchers/google-trends.ts"
      to: "google-trends-api"
      via: "dailyTrends()"
      pattern: "googleTrends\\.dailyTrends"
    - from: "lib/fetchers/google-trends.ts"
      to: "lib/utils/cache.ts"
      via: "getCached/setCache"
      pattern: "(getCached|setCache)"
---

<objective>
Create Google Trends fetcher with caching and graceful degradation.

Purpose: Fetch daily fashion trends from Google Trends as one of two data sources. Handle the brittleness of the unofficial API with defensive coding.
Output: Working Google Trends fetcher that returns RawTrend[] with fashion filtering and caching.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-collection/02-RESEARCH.md
@lib/fetchers/types.ts (will exist from 02-01)
@lib/utils/cache.ts (will exist from 02-01)
@lib/utils/rate-limiter.ts (will exist from 02-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Google Trends fetcher</name>
  <files>lib/fetchers/google-trends.ts</files>
  <action>
Create `lib/fetchers/google-trends.ts`:

Import google-trends-api (CommonJS module - use `import googleTrends from 'google-trends-api'`).
Import types from `@/lib/fetchers/types`.
Import cache utilities from `@/lib/utils/cache`.
Import rate limiter from `@/lib/utils/rate-limiter`.

Define fashion keywords array for filtering:
```typescript
const FASHION_KEYWORDS = [
  'fashion', 'style', 'clothing', 'wear', 'outfit', 'brand',
  'sneaker', 'shoe', 'dress', 'jacket', 'jeans', 'accessory',
  'streetwear', 'designer', 'luxury', 'vintage', 'aesthetic'
];
```

Create `fetchGoogleTrends(): Promise<FetchResult<RawTrend[]>>`:

1. Check rate limit first - if exceeded, return cached data or error
2. Try to get cached data (key: 'google-trends-daily', TTL: 1 hour)
3. If cache hit, return { success: true, data: cached, cached: true }
4. If cache miss, fetch from Google Trends:
   - Call `googleTrends.dailyTrends({ geo: 'US' })`
   - Parse JSON response (it returns a string)
   - Extract `data.default.trendingSearchesDays[0].trendingSearches`
5. Filter trends by FASHION_KEYWORDS (case-insensitive match in title)
6. Map to RawTrend[]:
   ```typescript
   {
     title: trend.title.query,
     score: parseTraffic(trend.formattedTraffic), // "50K+" -> 50000
     source: 'google' as SourceType,
     sourceUrl: `https://trends.google.com/trends/explore?q=${encodeURIComponent(trend.title.query)}`,
     metadata: {
       relatedQueries: trend.relatedQueries?.map(q => q.query) || [],
       image: trend.image?.imageUrl || null
     }
   }
   ```
7. Cache the result (1 hour TTL for fresh, 24 hour for stale fallback)
8. Return { success: true, data: trends }

Create helper `parseTraffic(formatted: string): number`:
- Parse "50K+" -> 50000, "1M+" -> 1000000, "500+" -> 500
- Handle edge cases (undefined, empty string) -> return 0

Wrap entire fetch in try-catch:
- On error, log error and try to return stale cache
- If no stale cache, return { success: false, error: error.message }

DO NOT throw errors - always return FetchResult to allow graceful degradation.
  </action>
  <verify>
`npx tsc --noEmit` passes.
Function signature matches: `fetchGoogleTrends(): Promise<FetchResult<RawTrend[]>>`
  </verify>
  <done>
Google Trends fetcher exports fetchGoogleTrends function that:
- Checks rate limit
- Returns cached data if available
- Fetches fresh data with fashion filtering
- Gracefully degrades on API failure
  </done>
</task>

<task type="auto">
  <name>Task 2: Create test endpoint</name>
  <files>app/api/test/google-trends/route.ts</files>
  <action>
Create `app/api/test/google-trends/route.ts`:

This is a manual test endpoint for development - NOT for production use.

```typescript
import { NextRequest } from 'next/server';
import { fetchGoogleTrends } from '@/lib/fetchers/google-trends';

export const dynamic = 'force-dynamic';

export async function GET(request: NextRequest) {
  // Only allow in development or with secret
  const authHeader = request.headers.get('authorization');
  const isDev = process.env.NODE_ENV === 'development';
  const hasSecret = authHeader === `Bearer ${process.env.CRON_SECRET}`;

  if (!isDev && !hasSecret) {
    return Response.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const result = await fetchGoogleTrends();

  return Response.json({
    success: result.success,
    cached: result.cached || false,
    count: result.data?.length || 0,
    data: result.data || [],
    error: result.error || null,
    timestamp: new Date().toISOString()
  });
}
```

This endpoint:
- Works in dev without auth
- Requires CRON_SECRET in production
- Returns full FetchResult for debugging
  </action>
  <verify>
`npm run dev` starts without errors.
`curl http://localhost:3000/api/test/google-trends` returns JSON response (may be empty data if Google blocks, but should not error).
  </verify>
  <done>
Test endpoint created at /api/test/google-trends.
Accessible in dev mode, requires CRON_SECRET in production.
Returns fetch result with count, data, cached status, and timestamp.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npm run build`
2. Test endpoint responds: `curl http://localhost:3000/api/test/google-trends`
3. Response includes expected fields: success, cached, count, data, timestamp
4. If data returned, trends have title, score, source='google', sourceUrl
</verification>

<success_criteria>
- [ ] lib/fetchers/google-trends.ts exports fetchGoogleTrends
- [ ] fetchGoogleTrends returns FetchResult<RawTrend[]>
- [ ] Fashion filtering applied using FASHION_KEYWORDS
- [ ] Caching implemented (1hr fresh, 24hr stale fallback)
- [ ] Rate limiting checked before API call
- [ ] Graceful degradation on API failure (returns stale cache or error)
- [ ] Test endpoint at /api/test/google-trends works in dev
- [ ] TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-collection/02-02-SUMMARY.md`
</output>
