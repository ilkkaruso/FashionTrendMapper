---
phase: 02-data-collection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - lib/fetchers/types.ts
  - lib/utils/cache.ts
  - lib/utils/rate-limiter.ts
  - vercel.json
autonomous: true
user_setup:
  - service: upstash-redis
    why: "Serverless Redis for caching and rate limiting"
    env_vars:
      - name: UPSTASH_REDIS_REST_URL
        source: "Upstash Console -> Database -> REST API -> UPSTASH_REDIS_REST_URL"
      - name: UPSTASH_REDIS_REST_TOKEN
        source: "Upstash Console -> Database -> REST API -> UPSTASH_REDIS_REST_TOKEN"
    dashboard_config:
      - task: "Create free Redis database"
        location: "console.upstash.com -> Create Database -> Select region (us-east-1)"

must_haves:
  truths:
    - "Dependencies installed and importable"
    - "Types define shared data structures for fetchers"
    - "Cache utility stores and retrieves data with TTL"
    - "Rate limiter prevents API abuse"
  artifacts:
    - path: "lib/fetchers/types.ts"
      provides: "Shared types for trend data"
      exports: ["RawTrend", "NormalizedTrend", "SourceType"]
    - path: "lib/utils/cache.ts"
      provides: "Redis-based caching"
      exports: ["getCached", "setCache", "getStaleCached"]
    - path: "lib/utils/rate-limiter.ts"
      provides: "Rate limiting for external APIs"
      exports: ["ratelimit", "checkRateLimit"]
    - path: "vercel.json"
      provides: "Cron job configuration"
      contains: "crons"
  key_links:
    - from: "lib/utils/cache.ts"
      to: "@upstash/redis"
      via: "Redis.fromEnv()"
      pattern: "Redis\\.fromEnv"
    - from: "lib/utils/rate-limiter.ts"
      to: "@upstash/ratelimit"
      via: "Ratelimit constructor"
      pattern: "new Ratelimit"
---

<objective>
Install Phase 2 dependencies and create foundational infrastructure for data fetching.

Purpose: Establish shared types, caching, and rate limiting utilities that Google Trends and Reddit fetchers will depend on.
Output: Installed packages, type definitions, caching utilities, rate limiter config, and vercel.json with cron configuration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-collection/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create types</name>
  <files>package.json, lib/fetchers/types.ts</files>
  <action>
Install required packages:
```bash
npm install google-trends-api snoowrap @upstash/ratelimit @upstash/redis
npm install -D @types/google-trends-api
```

Create `lib/fetchers/types.ts` with shared type definitions:
- `SourceType`: 'google' | 'reddit'
- `RawTrend`: Raw data from any source (title, score, source, sourceUrl?, metadata?)
- `NormalizedTrend`: Normalized 0-100 scale (title, score, sources, sourceBreakdown)
- `TrendWithHistory`: NormalizedTrend + change percentage from yesterday
- `FetchResult<T>`: { success: boolean, data?: T, error?: string, cached?: boolean }

Keep types simple - no over-engineering. These will be used by both fetchers and the normalizer.
  </action>
  <verify>
`npm ls google-trends-api snoowrap @upstash/ratelimit @upstash/redis` shows all packages installed.
`npx tsc --noEmit` passes without errors on types.ts.
  </verify>
  <done>
All 4 packages installed. Types file exports RawTrend, NormalizedTrend, TrendWithHistory, FetchResult, SourceType.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create caching and rate limiting utilities</name>
  <files>lib/utils/cache.ts, lib/utils/rate-limiter.ts, vercel.json</files>
  <action>
Create `lib/utils/cache.ts`:
- Initialize Redis client with `Redis.fromEnv()` (uses UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN)
- `getCached<T>(key: string): Promise<T | null>` - Returns cached value or null
- `setCache<T>(key: string, value: T, ttlSeconds: number): Promise<void>` - Sets value with TTL
- `getStaleCached<T>(key: string): Promise<T | null>` - Gets value even if expired (for fallback)
- Use `stale:${key}` pattern for stale cache (longer TTL, e.g., 24h)
- Handle Redis connection errors gracefully (log and return null, don't crash)

Create `lib/utils/rate-limiter.ts`:
- Initialize Ratelimit with sliding window algorithm
- `ratelimit` export: 10 requests per 10 seconds (for Google Trends)
- `redditRatelimit` export: 60 requests per minute (for Reddit)
- `checkRateLimit(limiter: Ratelimit, identifier: string)`: Returns { success, remaining, reset }
- If rate limit exceeded, throw descriptive error

Create `vercel.json` at project root:
```json
{
  "crons": [
    {
      "path": "/api/cron/fetch-trends",
      "schedule": "0 5 * * *"
    }
  ]
}
```
This schedules the cron job at 5am UTC daily (Hobby plan runs anywhere in hour 5).
  </action>
  <verify>
Files exist and compile: `npx tsc --noEmit`
vercel.json is valid JSON: `cat vercel.json | jq .`
  </verify>
  <done>
Cache utility connects to Upstash Redis with get/set/getStale functions.
Rate limiter configured with sliding window for Google (10/10s) and Reddit (60/min).
vercel.json configured with daily 5am UTC cron job path.
  </done>
</task>

</tasks>

<verification>
1. All packages in package.json dependencies: google-trends-api, snoowrap, @upstash/ratelimit, @upstash/redis
2. TypeScript compiles without errors: `npm run build` succeeds
3. Type exports importable: Create test import in any file
4. vercel.json valid and contains cron configuration
</verification>

<success_criteria>
- [ ] google-trends-api, snoowrap, @upstash/ratelimit, @upstash/redis installed
- [ ] lib/fetchers/types.ts exports RawTrend, NormalizedTrend, TrendWithHistory, FetchResult, SourceType
- [ ] lib/utils/cache.ts exports getCached, setCache, getStaleCached
- [ ] lib/utils/rate-limiter.ts exports ratelimit, redditRatelimit, checkRateLimit
- [ ] vercel.json created with cron job at /api/cron/fetch-trends
- [ ] TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-collection/02-01-SUMMARY.md`
</output>
